//! This module is responsible for serializing wire messages in `febft`.
//!
//! All relevant types transmitted over the wire are `serde` aware, if
//! this feature is enabled with `serialize_serde`. Slightly more exotic
//! serialization routines, for better throughput, can be utilized, such
//! as [Cap'n'Proto](https://capnproto.org/capnp-tool.html), but these are
//! expected to be implemented by the user.

use std::io::{Read, Write};

use crate::bft::communication::message::SystemMessage;
use crate::bft::crypto::hash::{Context, Digest};
use crate::bft::error::*;

use super::message::ConsensusMessage;

pub mod serialization_primitives;


/// Marker trait containing the types used by the application,
/// as well as routines to serialize the application data.
///
/// Both clients and replicas should implement this trait,
/// to communicate with each other.
/// This data type must be Send since it will be sent across
/// threads for processing and follow up reception
pub trait SharedData: Send {

    /// The application state, which is mutated by client
    /// requests.
    type State: Send + Clone;

    /// Represents the requests forwarded to replicas by the
    /// clients of the BFT system.
    type Request: Send + Clone;

    /// Represents the replies forwarded to clients by replicas
    /// in the BFT system.
    type Reply: Send + Clone;

    ///Serialize a state so it can be utilized by the SMR middleware
    ///  (either for network sending or persistent storing)
    fn serialize_state<W>(w: W, state: &Self::State) -> Result<()> where W: Write;

    ///Deserialize a state generated by the serialize_state function.
    fn deserialize_state<R>(r: R) -> Result<Self::State> where R: Read;

    ///Serialize a request from your service, given the writer to serialize into
    fn serialize_request<W>(w: W, request: &Self::Request) -> Result<()> where W: Write;

    ///Deserialize a request that was generated by the serialize request function above
    fn deserialize_request<R>(r: R) -> Result<Self::Request> where R: Read;

    ///Serialize a reply into a given writer
    fn serialize_reply<W>(w: W, reply: &Self::Reply) -> Result<()> where W: Write;

    ///Deserialize a reply that was generated using the serialize reply function above
    fn deserialize_reply<R>(r: R) -> Result<Self::Reply> where R: Read;
}

// max no. of bytes to inline before doing a heap alloc
//const NODE_BUFSIZ: usize = 16384;

/// The buffer type used to serialize messages into.
pub type Buf = Vec<u8>;

/// Extension of `SharedData` to obtain hash digests.
pub trait DigestData: SharedData {
    /// Convenience function to obtain the digest of a request upon
    /// serialization.
    fn serialize_digest<W: Write + AsRef<[u8]>> (
        message: &SystemMessage<Self::State, Self::Request, Self::Reply>,
        mut w: W,
    ) -> Result<Digest> {
        serialization_primitives::serialize_message::<W, Self>(&mut w, message)?;

        let mut ctx = Context::new();
        ctx.update(w.as_ref());
        Ok(ctx.finish())
    }

    fn deserialize_message<R: Read>(r: R) -> Result<SystemMessage<Self::State, Self::Request, Self::Reply>> {
        serialization_primitives::deserialize_message::<R, Self>(r)
    }
}

impl<D: SharedData> DigestData for D {}

/// The persister trait, to add functionality to the Shared Data struct.
/// The functionality added is ease of serialization for individual consensus messages, which 
/// are then going to be stored in the persistent log.
pub trait Persister: SharedData {

    fn serialize_consensus_message<W: Write> (
        message: &ConsensusMessage<Self::Request>,
        mut w: W,
    ) -> Result<()>{
        serialization_primitives::serialize_consensus::<W, Self>(&mut w, message)
    }

    fn deserialize_consensus_message<R: Read> (
        r: R
    ) -> Result<ConsensusMessage< Self::Request>> {
        serialization_primitives::deserialize_consensus::<R, Self>(r)
    }

}

impl<D: SharedData> Persister for D {}